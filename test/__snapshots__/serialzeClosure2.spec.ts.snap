// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`all binding patterns should be considered when detecting free variables 1`] = `
"const v1 = (free => (
// argument identifier
argument, 
// object binding pattern in argument
{ objArgument }, 
// array binding pattern in argument
[arrayArgument], 
// nested array binding pattern in argument
{ a: [arrayInObjectArgument] }, 
// nested object binding pattern in argument
{ b: { objectBindingInObjectBindingArgument } }) => {
    function notHoisted() {
        return \\"notHoisted\\";
    }
    const arrowFunction = () => \\"arrowFunction\\";
    const functionExpression = function () {
        return \\"functionExpression\\";
    };
    class ClassDeclaration {
        get() {
            return \\"ClassDeclaration\\";
        }
    }
    const ClassExpression = class {
        get() {
            return \\"ClassExpression\\";
        }
    };
    const NamedClassExpression = class NamedClassExpression {
        get() {
            return \\"NamedClassExpression\\";
        }
    };
    // single variable declaration with ts.Identifier
    const id = \\"id\\";
    // variable declaration list
    const a = \\"a\\", b = \\"b\\";
    // object binding pattern
    const { objPattern1, a: [arrayPatternInObject], } = {
        objPattern1: \\"objPattern1\\",
        a: [\\"arrayPatternInObject\\"],
    };
    // object binding patterns in a variable declaration list
    const { objPatternList1 } = {
        objPatternList1: \\"objPatternList1\\",
    }, { objPatternList2 } = {
        objPatternList2: \\"objPatternList2\\",
    };
    // array binding pattern
    const [arrayPattern1, { objPatternInArray }] = [
        \\"arrayPattern1\\",
        { objPatternInArray: \\"objPatternInArray\\" },
    ];
    // array binding pattern list
    const [arrayPatternList1] = [\\"arrayPatternList1\\"], [arrayPatternList2] = [\\"arrayPatternList2\\"];
    return [
        argument,
        objArgument,
        arrayArgument,
        arrayInObjectArgument,
        objectBindingInObjectBindingArgument,
        free,
        id,
        a,
        b,
        objPattern1,
        arrayPatternInObject,
        objPatternList1,
        objPatternList2,
        arrayPattern1,
        objPatternInArray,
        arrayPatternList1,
        arrayPatternList2,
        notHoisted(),
        hoisted(),
        arrowFunction(),
        functionExpression(),
        new ClassDeclaration().get(),
        new ClassExpression().get(),
        new NamedClassExpression().get(),
    ];
    function hoisted() {
        return \\"hoisted\\";
    }
})(\\"free\\");
exports.handler = v1"
`;

exports[`call the exports.handler if isFactoryFunction 1`] = `
"const v1 = (() => function expensiveTask() {
    return \\"world\\";
})();
const v2 = (expensiveTask => () => {
    const expensive = expensiveTask();
    return (handleInput) => {
        return \`\${handleInput} \${expensive}\`;
    };
})(v1);
exports.handler = v2()"
`;

exports[`capturing a reference to a function 1`] = `
"const v1 = (() => function foo() {
    return \\"hello\\";
})();
const v2 = (foo => () => foo())(v1);
exports.handler = v2"
`;

exports[`capturing a reference to a native bound function 1`] = `
"const v4 = ((native, code) => function Object() { [native, code]; })(undefined, undefined);
var v3 = { internal: \\"value\\" };
Object.setPrototypeOf(v3, v4.prototype);
const v2 = (_self => function foo() {
    return this.internal;
}.bind(_self))(v3);
const v5 = (f => () => f())(v2);
exports.handler = v5"
`;

exports[`capturing a reference to a string 1`] = `
"const v1 = (foo => () => foo)(\\"hello\\");
exports.handler = v1"
`;

exports[`capturing a reference to an array 1`] = `
"const v2 = (foo => () => foo)([\\"hello\\"]);
exports.handler = v2"
`;

exports[`capturing a reference to an array containing a function 1`] = `
"const v2 = (() => function bar() {
    return \\"hello\\";
})();
const v3 = (foo => () => foo)([v2]);
exports.handler = v3"
`;

exports[`class method 1`] = `
"const v2 = (() => class Foo {
    constructor(internal) {
        this.internal = internal;
    }
    foo() {
        return this.internal;
    }
})();
var v1 = { internal: \\"hello\\" };
Object.setPrototypeOf(v1, v2.prototype);
const v3 = (foo => () => foo.foo())(v1);
exports.handler = v3"
`;

exports[`class mix-in 1`] = `
"const v3 = (() => class {
    constructor(internal) {
        this.internal = internal;
    }
})();
const v2 = (Base => class extends Base {
    constructor(internal) {
        super(internal);
    }
    foo() {
        return this.internal;
    }
})(v3);
var v1 = { internal: \\"value\\" };
Object.setPrototypeOf(v1, v2.prototype);
const v4 = (a => () => a.foo())(v1);
exports.handler = v4"
`;

exports[`class with prototype swapped 1`] = `
"const v2 = (() => class B {
    constructor(internal) {
        this.internal = internal;
    }
    foo() {
        return \`\${this.internal} b\`;
    }
})();
const v1 = (A => class C extends A {
})(v2);
const v3 = (C => () => new C(\\"value\\").foo())(v1);
exports.handler = v3"
`;

exports[`super class method 1`] = `
"const v3 = (() => class Foo {
    constructor(internal) {
        this.internal = internal;
    }
    foo() {
        return this.internal;
    }
})();
const v2 = (Foo => class Bar extends Foo {
})(v3);
var v1 = { internal: \\"hello\\" };
Object.setPrototypeOf(v1, v2.prototype);
const v4 = (foo => () => foo.foo())(v1);
exports.handler = v4"
`;

exports[`traditional function prototype class 1`] = `
"const v3 = (() => function Animal(noise) {
    this.noise = noise;
})();
var v2 = { noise: \\"bork\\" };
Object.setPrototypeOf(v2, v3.prototype);
const v1 = (Animal => function Dog(noise) {
    Animal.call(this, \`bark \${noise}\`);
})(v3);
const v4 = ((Dog, animal) => () => [new Dog(\\"woof\\").speak(), animal.speak()])(v1, v2);
exports.handler = v4"
`;

exports[`value captured multiple times is only emitted once 1`] = `
"const v2 = (() => function bar() {
    return \\"hello\\";
})();
const v3 = (foo => () => foo)([v2, v2, v2]);
exports.handler = v3"
`;
