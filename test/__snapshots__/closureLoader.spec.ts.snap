// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`after hooks closure Analyze property chain #1 1`] = `
"const f1 = (() => function () {
    console.log(o.b.c);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #2 1`] = `
"const f1 = (() => function () {
    console.log(o.b);
    console.log(o.b.c);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #3 1`] = `
"const f1 = (() => function () {
    console.log(o.b);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #4 1`] = `
"const f1 = (() => function () {
    console.log(o.a);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #5 1`] = `
"const f1 = (() => function () {
    console.log(o.b.c.d);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #6 1`] = `
"const f1 = (() => function () {
    console.log(o.b.c.d);
    console.log(o.b);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #7 1`] = `
"const f1 = (() => function () {
    console.log(o.b.c.d);
    console.log(o.b.c);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #8 1`] = `
"const f1 = (() => function () {
    console.log(o.b.c.d);
    console.log(o.b.c);
    console.log(o.b);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #9 1`] = `
"const f1 = (() => function () {
    console.log(o.b.name);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #10 1`] = `
"const f1 = (() => function () {
    console.log(o.b.name);
    console.log(o.b());
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #11 1`] = `
"const f1 = (() => function () {
    console.log(o.b());
    console.log(o.b.name);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #12 1`] = `
"const f1 = (() => function () {
    console.log(o.b.name);
    console.log(o.b());
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #13 1`] = `
"const f1 = (() => function () {
    console.log(o.b());
    console.log(o.b.name);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #14 1`] = `
"const f1 = (() => function () {
    console.log(o2.b.d);
    console.log(o1);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #15 1`] = `
"const f1 = (() => function () {
    console.log(o1);
    console.log(o2.b.d);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #16 1`] = `
"const f1 = (() => function () {
    console.log(o2.b.c);
    console.log(o3.b.d);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #17 1`] = `
"const f1 = (() => function () {
    console.log(o2.b.d);
    console.log(o3.b.d);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #18 1`] = `
"const f1 = (() => function () {
    console.log(o2.b);
    console.log(o2.b.d);
    console.log(o3.b.d);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #19 1`] = `
"const f1 = (() => function () {
    console.log(o2.b.d);
    console.log(o3.b.d);
    console.log(o2.b);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #20 1`] = `
"const f1 = (() => function () {
    console.log(o2.b.d);
    console.log(o3.b.d);
    console.log(o1);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #21 1`] = `
"const f1 = (() => function () {
    console.log(o1);
    console.log(o2.b.d);
    console.log(o3.b.d);
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #22 1`] = `
"const f1 = (() => function () {
    console.log(getAll());
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #23 1`] = `
"const f1 = (() => function () {
    console.log(getAll());
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #24 1`] = `
"const f1 = (() => function () {
    console.log(getAll());
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #25 1`] = `
"const f1 = (() => function () {
    console.log(getAll());
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #26 1`] = `
"const f1 = (() => function () {
    console.log(getAll());
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #27 1`] = `
"const f1 = (() => function () {
    console.log(getAll());
})();
exports.handler = f1"
`;

exports[`after hooks closure Analyze property chain #28 1`] = `
"const f1 = (() => function () {
    console.log(getAll());
})();
exports.handler = f1"
`;

exports[`after hooks closure Arrow closure with this and arguments capture inside function closure 1`] = `
"const f1 = (() => function () {
    () => {
        console.log(this + arguments);
    };
})();
exports.handler = f1"
`;

exports[`after hooks closure Arrow closure with this capture inside function closure 1`] = `
"const f1 = (() => function () {
    () => {
        console.log(this);
    };
    return 0;
})();
exports.handler = f1"
`;

exports[`after hooks closure Async anonymous function closure (js) 1`] = `
"const f1 = (() => async function (a) { await a; })();
exports.handler = f1"
`;

exports[`after hooks closure Async anonymous function closure - extra space (js) 1`] = `
"const f1 = (() => async function (a) { await a; })();
exports.handler = f1"
`;

exports[`after hooks closure Async arrow function closure (js) 1`] = `
"const f1 = (() => async (a) => { await a; })();
exports.handler = f1"
`;

exports[`after hooks closure Async function that does capture this 1`] = `
"const f1 = (() => function () {
    return __awaiter(this, void 0, void 0, function* () {
        console.log(this);
        return 0;
    });
})();
exports.handler = f1"
`;

exports[`after hooks closure Async function that does not capture this 1`] = `
"const f1 = (() => function () {
    return __awaiter(this, void 0, void 0, function* () { });
})();
exports.handler = f1"
`;

exports[`after hooks closure Async lambda that does capture this 1`] = `
"const f1 = (() => () => __awaiter(void 0, void 0, void 0, function* () {
    console.log(this);
    return 0;
}))();
exports.handler = f1"
`;

exports[`after hooks closure Async lambda that does not capture this 1`] = `
"const f1 = (() => () => __awaiter(void 0, void 0, void 0, function* () { }))();
exports.handler = f1"
`;

exports[`after hooks closure Async named function closure (js) 1`] = `
"const f1 = (() => async function foo(a) { await a; })();
exports.handler = f1"
`;

exports[`after hooks closure Capture all if getter and getter uses this. #1 1`] = `
"const f1 = (() => function () {
    console.log(o.b);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture all if getter and getter uses this. #1.1 1`] = `
"const f1 = (() => function () {
    console.log(o[\\"b\\"]);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture all if object is used as is. 1`] = `
"const f1 = (() => function () {
    console.log(o);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture all if object property is invoked, and it uses this in nested arrow function. 1`] = `
"const f1 = (() => function () {
    console.log(o.c());
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture all if object property is invoked, and it uses this. #1 1`] = `
"const f1 = (() => function () {
    console.log(o.c());
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture all if object property is invoked, and it uses this. #1.1 1`] = `
"const f1 = (() => function () {
    console.log(o[\\"c\\"]());
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture all props from different contexts #1 1`] = `
"const f1 = (() => function f1() {
    console.log(o.a);
    f2();
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture all props from different contexts #1.1 1`] = `
"const f1 = (() => function f1() {
    console.log(o[\\"a\\"]);
    f2();
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture all props from different contexts #2 1`] = `
"const f1 = (() => function f1() {
    console.log(o);
    f2();
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture all props from different contexts #2.1 1`] = `
"const f1 = (() => function f1() {
    console.log(o);
    f2();
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture all props if prototype is accessed #2 1`] = `
Object {
  "exportName": "handler",
  "text": "exports.handler = __f0;

var __o_proto_proto = {};
Object.defineProperty(__f1, \\"prototype\\", { value: __o_proto_proto });
Object.defineProperty(__o_proto_proto, \\"constructor\\", { configurable: true, writable: true, value: __f1 });
Object.defineProperty(__o_proto_proto, \\"m\\", { configurable: true, writable: true, value: __f2 });
var __o_proto = Object.create(__o_proto_proto);
Object.defineProperty(__f3, \\"prototype\\", { value: __o_proto });
Object.setPrototypeOf(__f3, __f1);
Object.defineProperty(__o_proto, \\"constructor\\", { configurable: true, writable: true, value: __f3 });
Object.defineProperty(__o_proto, \\"n\\", { configurable: true, writable: true, value: __f4 });
var __o = Object.create(__o_proto);
__o.a = 1;
__o.b = 2;
function __f1() {
  return (function() {
    return function /*constructor*/() {
                this.a = 1;
            };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f2() {
  return (function() {
    return function /*m*/() {
                this.n();
            };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f3() {
  return (function() {
    let __super = __f1;

    return function /*constructor*/() {
    __super.call(this);
    this.b = 2;
};
  }).apply(undefined, undefined).apply(this, arguments);
}function __f4() {
  return (function() {
    let __super = __f1;

    return function /*n*/() { };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f0() {
  return (function() {
    let o = __o;

    return function () {
                o.m();
            };
  }).apply(undefined, undefined).apply(this, arguments);
}",
}
`;

exports[`after hooks closure Capture all props if prototype is accessed #2.1 1`] = `
"const f1 = (() => function () {
    o[\\"m\\"]();
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture all props if prototype is and uses this #1 1`] = `
Object {
  "exportName": "handler",
  "text": "exports.handler = __f0;

var __o_proto = {};
Object.defineProperty(__f1, \\"prototype\\", { value: __o_proto });
Object.defineProperty(__o_proto, \\"constructor\\", { configurable: true, writable: true, value: __f1 });
Object.defineProperty(__o_proto, \\"m\\", { configurable: true, writable: true, value: __f2 });
var __o = Object.create(__o_proto);
__o.a = 1;
__o.b = 2;
function __f1() {
  return (function() {
    return function /*constructor*/() {
                this.a = 1;
                this.b = 2;
            };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f2() {
  return (function() {
    return function /*m*/() {
                console.log(this);
                return 0;
            };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f0() {
  return (function() {
    let o = __o;

    return function () {
                o.m();
            };
  }).apply(undefined, undefined).apply(this, arguments);
}",
}
`;

exports[`after hooks closure Capture all props if prototype is and uses this #1.1 1`] = `
"const f1 = (() => function () {
    o[\\"m\\"]();
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture built in module by ref 1`] = `
"const f1 = (() => () => os)();
exports.handler = f1"
`;

exports[`after hooks closure Capture config created on the inside 1`] = `
Object {
  "exportName": "handler",
  "text": "exports.handler = __f0;

var __deploymentOnlyModule = {};
var __f1_prototype = {};
Object.defineProperty(__f1_prototype, \\"constructor\\", { configurable: true, writable: true, value: __f1 });
var __config = {[\\"test:TestingKey1\\"]: \\"TestingValue1\\", [\\"test:TestingKey2\\"]: \\"TestingValue2\\"};
var __runtimeConfig_1 = {getConfig: __getConfig};
Object.defineProperty(__f1_prototype, \\"get\\", { configurable: true, writable: true, value: __f2 });
Object.defineProperty(__f1_prototype, \\"fullKey\\", { configurable: true, writable: true, value: __f3 });
Object.defineProperty(__f1, \\"prototype\\", { value: __f1_prototype });
var __m = Object.create(Object.getPrototypeOf(global[\\"ts-jest\\"]));
Object.defineProperty(__m, \\"__esModule\\", { value: true });
__m.Config = __f1;
Object.defineProperty(__deploymentOnlyModule, \\"Config\\", { enumerable: true, get: __f4 });
function __f1(__0) {
  return (function() {
    return function /*constructor*/(name) {
        if (name.endsWith(\\":config\\")) {
            name = name.replace(/:config$/, \\"\\");
        }
        this.name = name;
    };
  }).apply(undefined, undefined).apply(this, arguments);
}function __getConfig(__0) {
  return (function() {
    let config = __config;
    let getConfig = __getConfig;

    return function /*getConfig*/(k) {
    return config[k];
};
  }).apply(undefined, undefined).apply(this, arguments);
}function __f2(__0) {
  return (function() {
    let runtimeConfig_1 = __runtimeConfig_1;

    return function /*get*/(key) {
        const v = (0, runtimeConfig_1.getConfig)(this.fullKey(key));
        if (v === undefined) {
            return undefined;
        }
        return v;
    };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f3(__0) {
  return (function() {
    return function /*fullKey*/(key) {
        return this.name + \\":\\" + key;
    };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f4() {
  return (function() {
    let m = __m;
    let k = \\"Config\\";

    return function () { return m[k]; };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f0() {
  return (function() {
    let deploymentOnlyModule = __deploymentOnlyModule;

    return function () {
                const v = new deploymentOnlyModule.Config(\\"test\\").get(\\"TestingKey2\\");
                console.log(v);
            };
  }).apply(undefined, undefined).apply(this, arguments);
}",
}
`;

exports[`after hooks closure Capture config created on the outside 1`] = `
Object {
  "exportName": "handler",
  "text": "exports.handler = __f0;

var __testConfig_proto = {};
Object.defineProperty(__f1, \\"prototype\\", { value: __testConfig_proto });
Object.defineProperty(__testConfig_proto, \\"constructor\\", { configurable: true, writable: true, value: __f1 });
var __config = {[\\"test:TestingKey1\\"]: \\"TestingValue1\\", [\\"test:TestingKey2\\"]: \\"TestingValue2\\"};
var __runtimeConfig_1 = {getConfig: __getConfig};
Object.defineProperty(__testConfig_proto, \\"get\\", { configurable: true, writable: true, value: __f2 });
Object.defineProperty(__testConfig_proto, \\"fullKey\\", { configurable: true, writable: true, value: __f3 });
var __testConfig = Object.create(__testConfig_proto);
__testConfig.name = \\"test\\";
function __f1(__0) {
  return (function() {
    return function /*constructor*/(name) {
        if (name.endsWith(\\":config\\")) {
            name = name.replace(/:config$/, \\"\\");
        }
        this.name = name;
    };
  }).apply(undefined, undefined).apply(this, arguments);
}function __getConfig(__0) {
  return (function() {
    let config = __config;
    let getConfig = __getConfig;

    return function /*getConfig*/(k) {
    return config[k];
};
  }).apply(undefined, undefined).apply(this, arguments);
}function __f2(__0) {
  return (function() {
    let runtimeConfig_1 = __runtimeConfig_1;

    return function /*get*/(key) {
        const v = (0, runtimeConfig_1.getConfig)(this.fullKey(key));
        if (v === undefined) {
            return undefined;
        }
        return v;
    };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f3(__0) {
  return (function() {
    return function /*fullKey*/(key) {
        return this.name + \\":\\" + key;
    };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f0() {
  return (function() {
    let testConfig = __testConfig;

    return function () {
                const v = testConfig.get(\\"TestingKey1\\");
                console.log(v);
            };
  }).apply(undefined, undefined).apply(this, arguments);
}",
}
`;

exports[`after hooks closure Capture default parameters 1`] = `
"const f1 = (() => (arg = defaultValue) => { })();
exports.handler = f1"
`;

exports[`after hooks closure Capture factory func #1 1`] = `
"const f1 = (() => () => {
    const serverlessExpress = require(\\"aws-serverless-express\\");
    const express = require(\\"express\\");
    const app = express();
    app.get(\\"/\\", (req, res) => {
        res.json({ succeeded: true });
    });
    const server = serverlessExpress.createServer(app);
    return (event, context) => {
        serverlessExpress.proxy(server, event, context);
    };
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture factory func #2 1`] = `
"const f1 = (() => function push() { [native, code]; })();
const f2 = (() => () => {
    outerVal.push({});
    foo();
    return (event, context) => {
        bar();
    };
})();
exports.handler = f2"
`;

exports[`after hooks closure Capture module through indirect function references 1`] = `
"const f1 = (() => () => handler)();
exports.handler = f1"
`;

exports[`after hooks closure Capture multi props from different contexts #1 1`] = `
"const f1 = (() => function f1() {
    console.log(o.a);
    f2();
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture multi props from different contexts #1.1 1`] = `
"const f1 = (() => function f1() {
    console.log(o[\\"a\\"]);
    f2();
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture no props if prototype is used but does not use this #1 1`] = `
Object {
  "exportName": "handler",
  "text": "exports.handler = __f0;

var __o = {};
Object.defineProperty(__o, \\"m\\", { configurable: true, writable: true, value: __f1 });
function __f1() {
  return (function() {
    return function /*m*/() { };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f0() {
  return (function() {
    let o = __o;

    return function () {
                o.m();
            };
  }).apply(undefined, undefined).apply(this, arguments);
}",
}
`;

exports[`after hooks closure Capture no props if prototype is used but does not use this #1.1 1`] = `
"const f1 = (() => function () {
    o[\\"m\\"]();
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture non-built-in module 1`] = `
"const f1 = (() => function () {
    typescript_1.default.parseCommandLine([\\"\\"]);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture numeric property 1`] = `
"const f1 = (() => function () {
    return array;
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture object with methods 1`] = `
"const f1 = (() => function () {
    console.log(obj);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture of exported variable #1 1`] = `
"const f1 = (() => function () {
    console.log(exports.exportedValue);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture of exported variable #2 1`] = `
"const f1 = (() => function () {
    console.log(exports.exportedValue);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture of exported variable #3 1`] = `
"const f1 = (() => function () {
    console.log(module.exports.exportedValue);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture one if getter and getter does not use this. #1 1`] = `
"const f1 = (() => function () {
    console.log(o.b);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture one if getter and getter does not use this. #1.1 1`] = `
"const f1 = (() => function () {
    console.log(o[\\"b\\"]);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture one if object property is captured, uses this, but is not invoked. #1 1`] = `
"const f1 = (() => function () {
    console.log(o.c);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture one if object property is captured, uses this, but is not invoked. #1.1 1`] = `
"const f1 = (() => function () {
    console.log(o[\\"c\\"]);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture one if object property is invoked, and it does not use this. #1 1`] = `
"const f1 = (() => function () {
    console.log(o.c());
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture one if object property is invoked, and it does not use this. #1.1 1`] = `
"const f1 = (() => function () {
    console.log(o[\\"c\\"]());
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture one if object property is invoked, but it uses this in nested function. 1`] = `
"const f1 = (() => function () {
    console.log(o.c());
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture subset if sub object property is invoked. #1 1`] = `
"const f1 = (() => function () {
    console.log(o.b.c());
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture subset if sub object property is invoked. #1.1 1`] = `
"const f1 = (() => function () {
    console.log(o[\\"b\\"][\\"c\\"]());
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture subset of properties #1 1`] = `
"const f1 = (() => function () {
    console.log(o.a);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture subset of properties #1.1 1`] = `
"const f1 = (() => function () {
    console.log(o[\\"a\\"]);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture subset of properties #2 1`] = `
"const f1 = (() => function () {
    console.log(o.b + o.c);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture subset of properties #2.1 1`] = `
"const f1 = (() => function () {
    console.log(o[\\"b\\"] + o[\\"c\\"]);
})();
exports.handler = f1"
`;

exports[`after hooks closure Capture user-defined module by value 1`] = `
"const f1 = (() => () => util)();
exports.handler = f1"
`;

exports[`after hooks closure Captures bigint 1`] = `
"const f1 = (() => function () {
    return zeroBigInt + smallBigInt + negativeBigInt + largeBigInt + negativeBigInt + negativeLargeBigInt;
})();
exports.handler = f1"
`;

exports[`after hooks closure Class complex statics 1`] = `
"const f1 = (() => () => {
    return new ClassWithMoreStatic();
})();
exports.handler = f1"
`;

exports[`after hooks closure Class complex statics only 1`] = `
"const f1 = (() => () => \\"x\\")();
const f2 = (() => () => new ClassWithMoreStatic())();
const f3 = (() => () => {
    ClassWithMoreStatic.S();
    ClassWithMoreStatic.SX();
    console.log(ClassWithMoreStatic.x);
})();
exports.handler = f3"
`;

exports[`after hooks closure Class nested statics 1`] = `
"const f1 = (() => () => {
    return c.x.S + c.x.T;
})();
exports.handler = f1"
`;

exports[`after hooks closure Class serialize all 1`] = `
"const f1 = (() => () => {
    const doSomething = (c) => { };
    return doSomething(ClassWithStatic);
})();
exports.handler = f1"
`;

exports[`after hooks closure Class statics 1`] = `
"const f1 = (() => () => {
    return ClassWithStatic.S;
})();
exports.handler = f1"
`;

exports[`after hooks closure Class statics with class invoke 1`] = `
"const f1 = (() => () => {
    const s = ClassWithStatic.S;
    const a = new ClassWithStatic();
    return s;
})();
exports.handler = f1"
`;

exports[`after hooks closure Class statics with prototype reference 1`] = `
"const f1 = (() => () => {
    console.log(ClassWithStatic);
    return ClassWithStatic.S;
})();
exports.handler = f1"
`;

exports[`after hooks closure Class statics without static reference 1`] = `
"const f1 = (() => () => {
    return new ClassWithStatic();
})();
exports.handler = f1"
`;

exports[`after hooks closure Cloud table function 1`] = `
"const f1 = (() => () => { })();
const f2 = (() => () => { })();
const f3 = (() => function testScanReturnsAllValues() {
    return __awaiter(this, void 0, void 0, function* () {
        yield table1.insert({
            [table1.primaryKey]: \\"val1\\",
            value1: 1,
            value2: \\"1\\",
        });
        yield table1.insert({
            [table1.primaryKey]: \\"val2\\",
            value1: 2,
            value2: \\"2\\",
        });
        const values = [];
        // @ts-ignore
        const value1 = values.find((v) => v[table1.primaryKey] === \\"val1\\");
        // @ts-ignore
        const value2 = values.find((v) => v[table1.primaryKey] === \\"val2\\");
    });
})();
exports.handler = f3"
`;

exports[`after hooks closure Complex capturing cases #1 1`] = `
"const f1 = (() => () => {
    // cap1 is captured here.
    // nocap1 introduces a new variable that shadows the outer one.
    let [nocap1 = cap1] = [];
    console.log(nocap1);
})();
exports.handler = f1"
`;

exports[`after hooks closure Complex capturing cases #2 1`] = `
"const f1 = (() => () => {
    // cap1 is captured here.
    // nocap1 introduces a new variable that shadows the outer one.
    let { nocap1 = cap1 } = {};
    console.log(nocap1);
})();
exports.handler = f1"
`;

exports[`after hooks closure Complex capturing cases #3 1`] = `
"const f1 = (() => () => {
    // cap1 is captured here.
    // nocap1 introduces a new variable that shadows the outer one.
    let { x: nocap1 = cap1 } = {};
    console.log(nocap1);
})();
exports.handler = f1"
`;

exports[`after hooks closure Complex property descriptor #1 1`] = `
"const f1 = (() => () => v)();
exports.handler = f1"
`;

exports[`after hooks closure Complex property descriptor #2 1`] = `
"const f1 = (() => () => v)();
exports.handler = f1"
`;

exports[`after hooks closure Cyclic object #1 1`] = `
"const f1 = (() => () => array)();
exports.handler = f1"
`;

exports[`after hooks closure Cyclic object #2 1`] = `
"const f1 = (() => () => obj)();
exports.handler = f1"
`;

exports[`after hooks closure Cyclic object #3 1`] = `
"const f1 = (() => () => obj)();
exports.handler = f1"
`;

exports[`after hooks closure Cyclic object #4 1`] = `
"const f1 = (() => () => obj2)();
exports.handler = f1"
`;

exports[`after hooks closure Declared variable in typeof 1`] = `
"const f1 = (() => function () {
    const x = typeof a;
})();
exports.handler = f1"
`;

exports[`after hooks closure Deconstructing arrow function 1`] = `
"const f1 = (() => ({ whatever }) => whatever)();
exports.handler = f1"
`;

exports[`after hooks closure Deconstructing async arrow function 1`] = `
"const f1 = (() => ({ whatever }) => __awaiter(void 0, void 0, void 0, function* () { return whatever; }))();
exports.handler = f1"
`;

exports[`after hooks closure Deconstructing async function 1`] = `
"const f1 = (() => function f({ whatever }) {
    return __awaiter(this, void 0, void 0, function* () {
        return whatever;
    });
})();
exports.handler = f1"
`;

exports[`after hooks closure Deconstructing function 1`] = `
"const f1 = (() => function f({ whatever }) {
    return whatever;
})();
exports.handler = f1"
`;

exports[`after hooks closure Do not capture #1 1`] = `
"const f1 = (() => function f1() {
    console.log(o);
})();
exports.handler = f1"
`;

exports[`after hooks closure Do not capture #2 1`] = `
"const f1 = (() => function f1() {
    console.log(o);
})();
exports.handler = f1"
`;

exports[`after hooks closure Do not capture non-existent prop #1 1`] = `
"const f1 = (() => function f1() {
    // @ts-ignore
    console.log(o.c);
})();
exports.handler = f1"
`;

exports[`after hooks closure Do not capture non-existent prop #1.1 1`] = `
"const f1 = (() => function f1() {
    // @ts-ignore
    console.log(o[\\"c\\"]);
})();
exports.handler = f1"
`;

exports[`after hooks closure Doesn't serialize global captures 1`] = `
"const f1 = (() => () => {
    console.log(\\"Just a global object reference\\");
})();
exports.handler = f1"
`;

exports[`after hooks closure Doesn't serialize non-free variables (but retains frees) 1`] = `
"const f1 = (() => (nocap1, nocap2) => {
    let zz = nocap1 + nocap2; // not a capture: args
    let yy = nocap3; // not a capture: var later on
    if (zz) {
        zz += cap1; // true capture
        let cap1 = 9; // because let is properly scoped
        zz += nocap4; // not a capture
        var nocap4 = 7; // because var is function scoped
        zz += cap2; // true capture
        const cap2 = 33;
        var nocap3 = 8; // block the above capture
    }
    let f1 = (nocap5) => {
        yy += nocap5; // not a capture: args
        cap3++; // capture
    };
    let f2 = (function (nocap6) {
        zz += nocap6; // not a capture: args
        if (cap4) { // capture
            yy = 0;
        }
    });
    let www = nocap7(); // not a capture; it is defined below
    if (true) {
        function nocap7() {
        }
    }
    let [{ t: [nocap8] }, nocap9 = \\"hello\\", ...nocap10] = [{ t: [true] }, null, undefined, 1, 2];
    let vvv = [nocap8, nocap9, nocap10]; // not a capture; declarations from destructuring
    let aaa = {
        [cap5]: cap6,
        [cap7]() {
            cap8;
        }
    };
})();
exports.handler = f1"
`;

exports[`after hooks closure Don't capture built-ins 1`] = `
"const f1 = (() => () => {
    let x = eval(\\"undefined + null + NaN + Infinity + __filename\\");
    require(\\"os\\");
})();
exports.handler = f1"
`;

exports[`after hooks closure Don't capture catch variables 1`] = `
"const f1 = (() => () => {
    try {
    }
    catch (err) {
        console.log(err);
    }
})();
exports.handler = f1"
`;

exports[`after hooks closure Don't serialize \`this\` in function expressions 1`] = `
"const f1 = (() => function () {
    return this;
})();
exports.handler = f1"
`;

exports[`after hooks closure Empty arrow closure 1`] = `
"const f1 = (() => () => { })();
exports.handler = f1"
`;

exports[`after hooks closure Empty arrow closure w/ args 1`] = `
"const f1 = (() => (x, y, z) => { })();
exports.handler = f1"
`;

exports[`after hooks closure Empty function closure 1`] = `
"const f1 = (() => function () { })();
exports.handler = f1"
`;

exports[`after hooks closure Empty function closure w/ args 1`] = `
"const f1 = (() => function (x, y, z) { })();
exports.handler = f1"
`;

exports[`after hooks closure Empty named function 1`] = `
"const f1 = (() => function f() { })();
exports.handler = f1"
`;

exports[`after hooks closure Function closure with this and arguments capture 1`] = `
"const f1 = (() => function () {
    console.log(this + arguments);
})();
exports.handler = f1"
`;

exports[`after hooks closure Function closure with this capture 1`] = `
"const f1 = (() => function () {
    console.log(this);
    return 0;
})();
exports.handler = f1"
`;

exports[`after hooks closure Function invoked with props 1`] = `
"const f1 = (() => () => {
    console.log(F());
})();
exports.handler = f1"
`;

exports[`after hooks closure Function with props 1`] = `
"const f1 = (() => () => {
    console.log(F.x);
})();
exports.handler = f1"
`;

exports[`after hooks closure Handle edge-case literals 1`] = `
"const f1 = (() => () => {
    const x = [a, b, c, d, e, f, g, h, i];
})();
exports.handler = f1"
`;

exports[`after hooks closure Invocation of async function that does capture this #1 1`] = `
"const f1 = (() => function () {
    return __awaiter(this, void 0, void 0, function* () {
        return 0;
    });
})();
const f2 = (() => function () {
    return __awaiter(this, void 0, void 0, function* () {
        return yield task.run();
    });
})();
exports.handler = f2"
`;

exports[`after hooks closure Invocation of async function that does not capture this #1 1`] = `
"const f1 = (() => function () {
    return __awaiter(this, void 0, void 0, function* () {
        return 0;
    });
})();
const f2 = (() => function () {
    return __awaiter(this, void 0, void 0, function* () {
        return yield task.run();
    });
})();
exports.handler = f2"
`;

exports[`after hooks closure Invocation of async lambda that does not capture this #1 1`] = `
"const f1 = (() => () => __awaiter(this, void 0, void 0, function* () { }))();
const f2 = (() => function () {
    return __awaiter(this, void 0, void 0, function* () {
        yield task.run();
    });
})();
exports.handler = f2"
`;

exports[`after hooks closure Merge simple functions 1`] = `
"const f1 = (() => function f3() {
    return lambda1(), lambda2();
})();
exports.handler = f1"
`;

exports[`after hooks closure Named function with self-reference 1`] = `
"const f1 = (() => function f() {
    if (false) {
        f();
    }
})();
exports.handler = f1"
`;

exports[`after hooks closure Object captured across multiple functions 1`] = `
"const f1 = (() => () => {
    f1();
    obj.a = 2;
    f2();
})();
exports.handler = f1"
`;

exports[`after hooks closure Regex #1 1`] = `
"const f1 = (() => function () {
    console.log(regex);
})();
exports.handler = f1"
`;

exports[`after hooks closure Regex #2 1`] = `
"const f1 = (() => function () {
    console.log(regex);
    foo();
})();
exports.handler = f1"
`;

exports[`after hooks closure Regex #3 (no flags) 1`] = `
"const f1 = (() => function () {
    console.log(regex);
    foo();
})();
exports.handler = f1"
`;

exports[`after hooks closure Remove specific syntax with a TypeScript transformer 1`] = `
"const f1 = (() => function foo() {
    wrap((text) => \`hello \${text}\`);
    const a = wrap((text) => \`hello \${text}\`);
    const b = [wrap((text) => \`hello \${text}\`)];
    const c = {
        prop: wrap((text) => \`hello \${text}\`),
    };
    function bar(...args) {
        const a = wrap((text) => \`hello \${text}\`);
        const b = [wrap((text) => \`hello \${text}\`)];
        const c = {
            prop: wrap((text) => \`hello \${text}\`),
        };
        return [a(\\"a\\"), b[0](\\"b\\"), c.prop(\\"c\\"), ...args];
    }
    return bar(a(\\"a\\"), b[0](\\"b\\"), c.prop(\\"c\\"));
})();
exports.handler = f1"
`;

exports[`after hooks closure Required packages #1 1`] = `
"const f1 = (() => function () {
    require(\\"typescript\\");
    foo();
    if (true) {
        require(\\"os\\");
    }
})();
exports.handler = f1"
`;

exports[`after hooks closure Respects package.json exports 1`] = `
"const f1 = (() => function reproHandler(input) {
    return __awaiter(this, void 0, void 0, function* () {
        const payload = getSchemaValidator().parse(input);
        return payload.message;
    });
})();
exports.handler = f1"
`;

exports[`after hooks closure Serialize class 1`] = `
Object {
  "exportName": "handler",
  "text": "exports.handler = __f0;

var __C = {};
var __array = [];
var __array_0 = {};
__array_0.o = 1;
__array_0.b = __array;
__array[0] = __array_0;
Object.defineProperty(__C, \\"s\\", { configurable: true, writable: true, value: __f1 });
function __f1() {
  return (function() {
    let array = __array;

    return function /*s*/() {
                return array;
            };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f0() {
  return (function() {
    let C = __C;

    return () => C.s();
  }).apply(undefined, undefined).apply(this, arguments);
}",
}
`;

exports[`after hooks closure Serialize class with constructor and field 1`] = `
Object {
  "exportName": "handler",
  "text": "exports.handler = __f0;

var __f1_prototype = {};
Object.defineProperty(__f1_prototype, \\"constructor\\", { configurable: true, writable: true, value: __f1 });
Object.defineProperty(__f1_prototype, \\"m\\", { configurable: true, writable: true, value: __f2 });
Object.defineProperty(__f1_prototype, \\"n\\", { configurable: true, writable: true, value: __f3 });
Object.defineProperty(__f1, \\"prototype\\", { value: __f1_prototype });
Object.defineProperty(__f1, \\"s\\", { configurable: true, writable: true, value: __f4 });
function __f1() {
  return (function() {
    return function /*constructor*/() {
                this.x = 1;
            };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f2() {
  return (function() {
    return function /*m*/() {
                return this.n();
            };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f3() {
  return (function() {
    return function /*n*/() {
                return this.x;
            };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f4(__0) {
  return (function() {
    return function /*s*/(c) {
                return c.n();
            };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f0() {
  return (function() {
    let C = __f1;

    return () => C.s(new C());
  }).apply(undefined, undefined).apply(this, arguments);
}",
}
`;

exports[`after hooks closure Serialize constructed class 1`] = `
"const f1 = (() => () => new C())();
exports.handler = f1"
`;

exports[`after hooks closure Serialize es5-style class 1`] = `
"const f1 = (() => () => new C().n())();
exports.handler = f1"
`;

exports[`after hooks closure Serialize instance class methods 1`] = `
Object {
  "exportName": "handler",
  "text": "exports.handler = __m;

var __boundThis_proto = {};
Object.defineProperty(__f0, \\"prototype\\", { value: __boundThis_proto });
Object.defineProperty(__boundThis_proto, \\"constructor\\", { configurable: true, writable: true, value: __f0 });
Object.defineProperty(__boundThis_proto, \\"m\\", { configurable: true, writable: true, value: __f1 });
Object.defineProperty(__boundThis_proto, \\"n\\", { configurable: true, writable: true, value: __f2 });
var __boundThis = Object.create(__boundThis_proto);
function __f0() {
  return (function() {
    return function /*constructor*/() { };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f1() {
  return (function() {
    return function /*m*/() {
                return this.n();
            };
  }).apply(undefined, undefined).apply(this, arguments);
}function __f2() {
  return (function() {
    return function /*n*/() {
                return 0;
            };
  }).apply(undefined, undefined).apply(this, arguments);
}function __m() {
  return (function() {
    let __boundThis = __boundThis;
    let m = __m;

    return function /*m*/() {
                return this.n();
            };
  }).apply(undefined, undefined).apply(this, arguments);
}",
}
`;

exports[`after hooks closure Serialize instance class methods, forget to bind 1`] = `
Object {
  "exportName": "handler",
  "text": "exports.handler = __f0;
function __f0() {
  return (function() {
    return function /*m*/() {
                return this.n();
            };
  }).apply(undefined, undefined).apply(this, arguments);
}",
}
`;

exports[`after hooks closure Serialize method with reserved name 1`] = `
Object {
  "exportName": "handler",
  "text": "exports.handler = __f0;
function __f0() {
  return (function() {
    return function /*delete*/() {
                return 0;
            };
  }).apply(undefined, undefined).apply(this, arguments);
}",
}
`;

exports[`after hooks closure Serialize mutable objects by value at the time of capture (post-mutation) 1`] = `
"const f1 = (() => function () {
    return mutable;
})();
exports.handler = f1"
`;

exports[`after hooks closure Serialize mutable objects by value at the time of capture (pre-mutation) 1`] = `
"const f1 = (() => function () {
    return mutable;
})();
exports.handler = f1"
`;

exports[`after hooks closure Serialize static class methods (es5 class style) 1`] = `
"const f1 = (() => function () {
    return this.n();
})();
exports.handler = f1"
`;

exports[`after hooks closure Serialize static class methods 1`] = `
Object {
  "exportName": "handler",
  "text": "exports.handler = __f0;
function __f0() {
  return (function() {
    return function /*m*/() {
                return this.n();
            };
  }).apply(undefined, undefined).apply(this, arguments);
}",
}
`;

exports[`after hooks closure Serializes basic captures 1`] = `
"const f1 = (() => () => {
    return wcap + \`\${xcap}\` + ycap.length + zcap.a + zcap.b + zcap.c;
})();
exports.handler = f1"
`;

exports[`after hooks closure Serializes recursive function captures 1`] = `
"const f1 = (() => function () {
    console.log(fff);
})();
const f2 = (() => () => {
    console.log(ggg);
})();
const f3 = (() => () => {
    xcap.fff();
    xcap.ggg();
    xcap.zzz.a[0](\\"x\\", \\"y\\");
})();
exports.handler = f3"
`;

exports[`after hooks closure Share __awaiter functions 1`] = `
"const f1 = (() => function f3() {
    const v1 = awaiter1, v2 = awaiter2;
})();
exports.handler = f1"
`;

exports[`after hooks closure Test Symbol.iterator 1`] = `
"const f1 = (() => () => C)();
exports.handler = f1"
`;

exports[`after hooks closure Test anonymous generator func 1`] = `
"const f1 = (() => function* () {
    yield 1;
})();
exports.handler = f1"
`;

exports[`after hooks closure Test array #1 1`] = `
"const f1 = (() => () => v)();
exports.handler = f1"
`;

exports[`after hooks closure Test array #2 1`] = `
"const f1 = (() => () => v)();
exports.handler = f1"
`;

exports[`after hooks closure Test class extension 1`] = `
"const f1 = (() => () => C)();
exports.handler = f1"
`;

exports[`after hooks closure Test computed method name. 1`] = `
"const f1 = (() => () => C)();
exports.handler = f1"
`;

exports[`after hooks closure Test function with property 1`] = `
"const f1 = (() => () => {
    return 1;
})();
exports.handler = f1"
`;

exports[`after hooks closure Test generator func 1`] = `
"const f1 = (() => function* f() {
    yield 1;
})();
exports.handler = f1"
`;

exports[`after hooks closure Test getter/setter #1 1`] = `
"const f1 = (() => () => C)();
exports.handler = f1"
`;

exports[`after hooks closure Test getter/setter #2 1`] = `
"const f1 = (() => () => C)();
exports.handler = f1"
`;

exports[`after hooks closure Test non-default function prototype 1`] = `
"const f1 = (() => () => {
    return 0;
})();
exports.handler = f1"
`;

exports[`after hooks closure Test non-default object prototype 1`] = `
"const f1 = (() => () => {
    return x;
})();
exports.handler = f1"
`;

exports[`after hooks closure Test null prototype 1`] = `
"const f1 = (() => () => {
    return x;
})();
exports.handler = f1"
`;

exports[`after hooks closure Test recursive prototype object prototype 1`] = `
"const f1 = (() => () => {
    return x;
})();
exports.handler = f1"
`;

exports[`after hooks closure Test symbols #1 1`] = `
"const f1 = (() => () => C)();
exports.handler = f1"
`;

exports[`after hooks closure Three level inheritance 1`] = `
"const f1 = (() => () => C)();
exports.handler = f1"
`;

exports[`after hooks closure Three level inheritance with symbols 1`] = `
"const f1 = (() => () => C)();
exports.handler = f1"
`;

exports[`after hooks closure Two level static inheritance 1`] = `
"const f1 = (() => () => B)();
exports.handler = f1"
`;

exports[`after hooks closure Undeclared variable in typeof 1`] = `
"const f1 = (() => function () {
    // @ts-ignore
    const x = typeof a;
})();
exports.handler = f1"
`;

exports[`after hooks closure Wrapped lambda function 1`] = `
"const f1 = (() => (a, b, c) => {
    const v = os;
    return { v };
})();
exports.handler = f1"
`;
